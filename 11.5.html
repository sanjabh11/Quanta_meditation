<html><head><base href="https://websim.universe/%203d%20amimation%20-%20Spacetime%20view%20of%20a%20moving%20object."><title>Relativistic Spacetime Visualizer</title>
<style>
    body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; font-family: Arial, sans-serif; background-color: #000000; color: #ffffff; }
    #canvas { width: 100%; height: 100%; }
    #info-panel {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(0,0,0,0.7);
        padding: 20px;
        border-radius: 10px;
        max-width: 300px;
    }
    #controls {
        position: absolute;
        bottom: 10px;
        left: 10px;
    }
    button {
        background: #4a4a8a;
        border: none;
        color: white;
        padding: 10px 20px;
        text-align: center;
        text-decoration: none;
        display: inline-block;
        font-size: 16px;
        margin: 4px 2px;
        cursor: pointer;
        border-radius: 5px;
        transition: background 0.3s;
    }
    button:hover {
        background: #6a6aaa;
    }
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="info-panel">
    <h2>Relativistic Spacetime Visualizer</h2>
    <p>This visualization demonstrates the concept of relativity of simultaneity in spacetime.</p>
    <p>The angled planes represent "now" slices for different observers moving at different velocities.</p>
    <p>The red line represents a moving object's worldline through spacetime.</p>
    <p>Use controls to change perspective and toggle different elements.</p>
</div>
<div id="controls">
    <button id="toggleRotation">Toggle Rotation</button>
    <button id="toggleObserver1">Toggle Observer 1</button>
    <button id="toggleObserver2">Toggle Observer 2</button>
    <button id="toggleWorldline">Toggle Worldline</button>
</div>

<script>
    let scene, camera, renderer, spacetimeBlock, observer1, observer2, worldline;
    let rotating = true;
    let showObserver1 = true;
    let showObserver2 = true;
    let showWorldline = true;

    function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        renderer = new THREE.WebGLRenderer({canvas: document.getElementById('canvas'), antialias: true});
        renderer.setSize(window.innerWidth, window.innerHeight);

        createSpacetimeBlock();
        createObservers();
        createWorldline();

        camera.position.set(5, 5, 10);
        camera.lookAt(0, 0, 0);
    }

    function createSpacetimeBlock() {
        const geometry = new THREE.BoxGeometry(4, 4, 4);
        const material = new THREE.MeshBasicMaterial({
            color: 0x444444,
            transparent: true,
            opacity: 0.2,
            wireframe: true
        });
        spacetimeBlock = new THREE.Mesh(geometry, material);
        scene.add(spacetimeBlock);
    }

    function createObservers() {
        const planeGeometry = new THREE.PlaneGeometry(4, 4);
        
        const material1 = new THREE.MeshBasicMaterial({
            color: 0x00ff00,
            transparent: true,
            opacity: 0.5,
            side: THREE.DoubleSide
        });
        observer1 = new THREE.Mesh(planeGeometry, material1);
        observer1.rotation.x = Math.PI / 4;
        scene.add(observer1);

        const material2 = new THREE.MeshBasicMaterial({
            color: 0x0000ff,
            transparent: true,
            opacity: 0.5,
            side: THREE.DoubleSide
        });
        observer2 = new THREE.Mesh(planeGeometry, material2);
        observer2.rotation.x = Math.PI / 6;
        observer2.rotation.y = Math.PI / 6;
        scene.add(observer2);
    }

    function createWorldline() {
        const curve = new THREE.CubicBezierCurve3(
            new THREE.Vector3(-2, -2, -2),
            new THREE.Vector3(-1, 0, 0),
            new THREE.Vector3(1, 0, 0),
            new THREE.Vector3(2, 2, 2)
        );

        const points = curve.getPoints(50);
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const material = new THREE.LineBasicMaterial({ color: 0xff0000 });

        worldline = new THREE.Line(geometry, material);
        scene.add(worldline);
    }

    function animate() {
        requestAnimationFrame(animate);

        if (rotating) {
            spacetimeBlock.rotation.x += 0.005;
            spacetimeBlock.rotation.y += 0.005;
            observer1.rotation.y += 0.005;
            observer2.rotation.z += 0.005;
            worldline.rotation.x += 0.005;
            worldline.rotation.y += 0.005;
        }

        observer1.visible = showObserver1;
        observer2.visible = showObserver2;
        worldline.visible = showWorldline;

        renderer.render(scene, camera);
    }

    init();
    animate();

    document.getElementById('toggleRotation').addEventListener('click', () => {
        rotating = !rotating;
    });

    document.getElementById('toggleObserver1').addEventListener('click', () => {
        showObserver1 = !showObserver1;
    });

    document.getElementById('toggleObserver2').addEventListener('click', () => {
        showObserver2 = !showObserver2;
    });

    document.getElementById('toggleWorldline').addEventListener('click', () => {
        showWorldline = !showWorldline;
    });

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>